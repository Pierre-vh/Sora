// NOTE: CHECK lines have been generated by utils/update_filecheck_test.py
// RUN: sorac -sema-only -dump-ast %s | FileCheck %s

// @TEST_PATTERN .*Expr
// @TEST_PATTERN .*Decl

// FIXME: Split this test into multiple files.

func foo(x: usize) -> (i8, maybe i32, &mut usize) {
  // Returning a reference to a local isn't good, but the typechecker doesn't know :)
  let mut z: usize = 0
  return (0, 0, &z)
}

func types() -> (u8, u16, u32, u64, usize, i8, i16, i32, i64, isize, f32, f64) {
  let _: i8 = 0 + 0 + 0 % 0
  ((0 as i8 + 0) * 0) + 0
  let _ :i8 = 1 << 8

  let mut emptyTuple = ()
  let mut voidVal: void
  voidVal = emptyTuple
  emptyTuple = voidVal

  let mut maybeVI32: maybe i32
  let mut maybeMaybeVI8: maybe maybe i8

  maybeVI32 ??= 0
  maybeMaybeVI8 ??= 0

  (((0 as i8) + 0) + 1) * 2

  let z = foo(0)

  let mut cond = false
  let _: i8 = cond ? 0 : 1
  let _ = cond ? null : null

  let immutTuple : (i32, &i32, &mut i32)
  immutTuple.0
  immutTuple.1
  immutTuple.2

  return (8, 16, 32, 64, 0, 8, 16, +32, -64, +0, +3.14, -3.6)
}

// FIXME: this is a duplicate from memberref.sora
func membacc(a: &mut ((i32, i32), i16), b: (i32, i16), c: &((i32, i32), i16)) {
    (a->0).0
    b.0
    (c->0).0
}

func implicit(a: i8) {
  let (_, _, (_, _)) : (maybe i32, maybe i32, (maybe i32, maybe i32)) = (0, 0, (0, 0))
  let _: maybe &i8 = &a
  let a = (a, a)
  let _ : (maybe i8, maybe i8) = a
}

func unwrap(z: maybe maybe i32) {
  z!!
}

func deref(ref: &mut i32) {
  *ref = 0
}

func casts(a: &mut i8, x: i64, y: usize, z: f32) {
  0 as u16
  z as f32 as usize as f64
  y as u8
  x as usize
  true as u8 as bool
  a as maybe &i8
}

func tuples() {
  ()
  (0)
  (0, 1)
  (0, 2, 3)
}

// CHECK:         FuncDecl type=(usize) -> (i8, maybe i32, &mut usize) identifier=foo identifierLoc=line:9:6 fnLoc=line:9:1
// CHECK:            ParamDecl type=usize identifier=x identifierLoc=line:9:10
// CHECK:            LetDecl letLoc=line:11:3 equalLoc=line:11:20
// CHECK:                    VarDecl type=usize identifier=z identifierLoc=line:11:11 mutable
// CHECK:              IntegerLiteralExpr type=usize loc=line:11:22 str='0' value=0
// CHECK:              TupleExpr type=(i8, maybe i32, &mut usize) numElements=3 lParenLoc=line:12:10 rParenLoc=line:12:19
// CHECK-NEXT:           IntegerLiteralExpr type=i8 loc=line:12:11 str='0' value=0
// CHECK-NEXT:           ImplicitMaybeConversionExpr implicit type=maybe i32
// CHECK-NEXT:             IntegerLiteralExpr type=i32 loc=line:12:14 str='0' value=0
// CHECK-NEXT:           UnaryExpr type=&mut usize & (AddressOf) opLoc=line:12:17
// CHECK-NEXT:             DeclRefExpr type=@lvalue usize loc=line:12:18 decl='z'@line:11:11
// CHECK-NEXT:   FuncDecl type=() -> (u8, u16, u32, u64, usize, i8, i16, i32, i64, isize, f32, f64) identifier=types identifierLoc=line:15:6 fnLoc=line:15:1
// CHECK:            LetDecl letLoc=line:16:3 equalLoc=line:16:13
// CHECK:              BinaryExpr type=i8 + (Add) opLoc=line:16:21
// CHECK-NEXT:           BinaryExpr type=i8 + (Add) opLoc=line:16:17
// CHECK-NEXT:             IntegerLiteralExpr type=i8 loc=line:16:15 str='0' value=0
// CHECK-NEXT:             IntegerLiteralExpr type=i8 loc=line:16:19 str='0' value=0
// CHECK-NEXT:           BinaryExpr type=i8 % (Rem) opLoc=line:16:25
// CHECK-NEXT:             IntegerLiteralExpr type=i8 loc=line:16:23 str='0' value=0
// CHECK-NEXT:             IntegerLiteralExpr type=i8 loc=line:16:27 str='0' value=0
// CHECK-NEXT:       BinaryExpr type=i8 + (Add) opLoc=line:17:23
// CHECK-NEXT:         ParenExpr type=i8 lParenLoc=line:17:3 rParenLoc=line:17:21
// CHECK-NEXT:           BinaryExpr type=i8 * (Mul) opLoc=line:17:18
// CHECK-NEXT:             ParenExpr type=i8 lParenLoc=line:17:4 rParenLoc=line:17:16
// CHECK-NEXT:               BinaryExpr type=i8 + (Add) opLoc=line:17:13
// CHECK-NEXT:                 CastExpr type=i8 asLoc=line:17:7 useless
// CHECK-NEXT:                   IntegerLiteralExpr type=i8 loc=line:17:5 str='0' value=0
// CHECK:                      IntegerLiteralExpr type=i8 loc=line:17:15 str='0' value=0
// CHECK-NEXT:             IntegerLiteralExpr type=i8 loc=line:17:20 str='0' value=0
// CHECK-NEXT:         IntegerLiteralExpr type=i8 loc=line:17:25 str='0' value=0
// CHECK-NEXT:       LetDecl letLoc=line:18:3 equalLoc=line:18:13
// CHECK:              BinaryExpr type=i8 << (Shl) opLoc=line:18:17
// CHECK-NEXT:           IntegerLiteralExpr type=i8 loc=line:18:15 str='1' value=1
// CHECK-NEXT:           IntegerLiteralExpr type=i32 loc=line:18:20 str='8' value=8
// CHECK-NEXT:       LetDecl letLoc=line:20:3 equalLoc=line:20:22
// CHECK:                  VarDecl type=() identifier=emptyTuple identifierLoc=line:20:11 mutable
// CHECK-NEXT:         TupleExpr type=() numElements=0 lParenLoc=line:20:24 rParenLoc=line:20:25
// CHECK-NEXT:       LetDecl letLoc=line:21:3
// CHECK:                    VarDecl type=void identifier=voidVal identifierLoc=line:21:11 mutable
// CHECK:            BinaryExpr type=() = (Assign) opLoc=line:22:11
// CHECK-NEXT:         DeclRefExpr type=@lvalue void loc=line:22:3 decl='voidVal'@line:21:11
// CHECK-NEXT:         LoadExpr implicit type=()
// CHECK-NEXT:           DeclRefExpr type=@lvalue () loc=line:22:13 decl='emptyTuple'@line:20:11
// CHECK-NEXT:       BinaryExpr type=void = (Assign) opLoc=line:23:14
// CHECK-NEXT:         DeclRefExpr type=@lvalue () loc=line:23:3 decl='emptyTuple'@line:20:11
// CHECK-NEXT:         LoadExpr implicit type=void
// CHECK-NEXT:           DeclRefExpr type=@lvalue void loc=line:23:16 decl='voidVal'@line:21:11
// CHECK-NEXT:       LetDecl letLoc=line:25:3
// CHECK:                    VarDecl type=maybe i32 identifier=maybeVI32 identifierLoc=line:25:11 mutable
// CHECK:            LetDecl letLoc=line:26:3
// CHECK:                    VarDecl type=maybe maybe i8 identifier=maybeMaybeVI8 identifierLoc=line:26:11 mutable
// CHECK:            BinaryExpr type=i32 ??= (NullCoalesceAssign) opLoc=line:28:13
// CHECK-NEXT:         DeclRefExpr type=@lvalue maybe i32 loc=line:28:3 decl='maybeVI32'@line:25:11
// CHECK-NEXT:         IntegerLiteralExpr type=i32 loc=line:28:17 str='0' value=0
// CHECK-NEXT:       BinaryExpr type=maybe i8 ??= (NullCoalesceAssign) opLoc=line:29:17
// CHECK-NEXT:         DeclRefExpr type=@lvalue maybe maybe i8 loc=line:29:3 decl='maybeMaybeVI8'@line:26:11
// CHECK-NEXT:         ImplicitMaybeConversionExpr implicit type=maybe i8
// CHECK-NEXT:           IntegerLiteralExpr type=i8 loc=line:29:21 str='0' value=0
// CHECK-NEXT:       BinaryExpr type=i8 * (Mul) opLoc=line:31:25
// CHECK-NEXT:         ParenExpr type=i8 lParenLoc=line:31:3 rParenLoc=line:31:23
// CHECK-NEXT:           BinaryExpr type=i8 + (Add) opLoc=line:31:20
// CHECK-NEXT:             ParenExpr type=i8 lParenLoc=line:31:4 rParenLoc=line:31:18
// CHECK-NEXT:               BinaryExpr type=i8 + (Add) opLoc=line:31:15
// CHECK-NEXT:                 ParenExpr type=i8 lParenLoc=line:31:5 rParenLoc=line:31:13
// CHECK-NEXT:                   CastExpr type=i8 asLoc=line:31:8 useless
// CHECK-NEXT:                     IntegerLiteralExpr type=i8 loc=line:31:6 str='0' value=0
// CHECK:                      IntegerLiteralExpr type=i8 loc=line:31:17 str='0' value=0
// CHECK-NEXT:             IntegerLiteralExpr type=i8 loc=line:31:22 str='1' value=1
// CHECK-NEXT:         IntegerLiteralExpr type=i8 loc=line:31:27 str='2' value=2
// CHECK-NEXT:       LetDecl letLoc=line:33:3 equalLoc=line:33:9
// CHECK:                VarDecl type=(i8, maybe i32, &mut usize) identifier=z identifierLoc=line:33:7 immutable
// CHECK-NEXT:         CallExpr type=(i8, maybe i32, &mut usize) lParenLoc=line:33:14 rParenLoc=line:33:16 numArgs=1
// CHECK-NEXT:           DeclRefExpr type=(usize) -> (i8, maybe i32, &mut usize) loc=line:33:11 decl='foo'@line:9:6
// CHECK-NEXT:           IntegerLiteralExpr type=usize loc=line:33:15 str='0' value=0
// CHECK-NEXT:       LetDecl letLoc=line:35:3 equalLoc=line:35:16
// CHECK:                  VarDecl type=bool identifier=cond identifierLoc=line:35:11 mutable
// CHECK-NEXT:         BooleanLiteralExpr type=bool loc=line:35:18 value=false
// CHECK-NEXT:       LetDecl letLoc=line:36:3 equalLoc=line:36:13
// CHECK:              ConditionalExpr type=i8 questionLoc=line:36:20 colonLoc=line:36:24
// CHECK-NEXT:           LoadExpr implicit type=bool
// CHECK-NEXT:             DeclRefExpr type=@lvalue bool loc=line:36:15 decl='cond'@line:35:11
// CHECK-NEXT:           IntegerLiteralExpr type=i8 loc=line:36:22 str='0' value=0
// CHECK-NEXT:           IntegerLiteralExpr type=i8 loc=line:36:26 str='1' value=1
// CHECK-NEXT:       LetDecl letLoc=line:37:3 equalLoc=line:37:9
// CHECK:              ConditionalExpr type=null questionLoc=line:37:16 colonLoc=line:37:23
// CHECK-NEXT:           LoadExpr implicit type=bool
// CHECK-NEXT:             DeclRefExpr type=@lvalue bool loc=line:37:11 decl='cond'@line:35:11
// CHECK-NEXT:           NullLiteralExpr type=null loc=line:37:18
// CHECK-NEXT:           NullLiteralExpr type=null loc=line:37:25
// CHECK-NEXT:       LetDecl letLoc=line:39:3
// CHECK:                  VarDecl type=(i32, &i32, &mut i32) identifier=immutTuple identifierLoc=line:39:7 immutable
// CHECK:            LoadExpr implicit type=i32
// CHECK-NEXT:         TupleElementExpr type=@lvalue i32 dot opLoc=line:40:13 index=0 indexLoc=line:40:14
// CHECK-NEXT:           DeclRefExpr type=@lvalue (i32, &i32, &mut i32) loc=line:40:3 decl='immutTuple'@line:39:7
// CHECK-NEXT:       LoadExpr implicit type=&i32
// CHECK-NEXT:         TupleElementExpr type=@lvalue &i32 dot opLoc=line:41:13 index=1 indexLoc=line:41:14
// CHECK-NEXT:           DeclRefExpr type=@lvalue (i32, &i32, &mut i32) loc=line:41:3 decl='immutTuple'@line:39:7
// CHECK-NEXT:       LoadExpr implicit type=&mut i32
// CHECK-NEXT:         TupleElementExpr type=@lvalue &mut i32 dot opLoc=line:42:13 index=2 indexLoc=line:42:14
// CHECK-NEXT:           DeclRefExpr type=@lvalue (i32, &i32, &mut i32) loc=line:42:3 decl='immutTuple'@line:39:7
// CHECK:              TupleExpr type=(u8, u16, u32, u64, usize, i8, i16, i32, i64, isize, f32, f64) numElements=12 lParenLoc=line:44:10 rParenLoc=line:44:61
// CHECK-NEXT:           IntegerLiteralExpr type=u8 loc=line:44:11 str='8' value=8
// CHECK-NEXT:           IntegerLiteralExpr type=u16 loc=line:44:14 str='16' value=16
// CHECK-NEXT:           IntegerLiteralExpr type=u32 loc=line:44:18 str='32' value=32
// CHECK-NEXT:           IntegerLiteralExpr type=u64 loc=line:44:22 str='64' value=64
// CHECK-NEXT:           IntegerLiteralExpr type=usize loc=line:44:26 str='0' value=0
// CHECK-NEXT:           IntegerLiteralExpr type=i8 loc=line:44:29 str='8' value=8
// CHECK-NEXT:           IntegerLiteralExpr type=i16 loc=line:44:32 str='16' value=16
// CHECK-NEXT:           UnaryExpr type=i32 + (Plus) opLoc=line:44:36
// CHECK-NEXT:             IntegerLiteralExpr type=i32 loc=line:44:37 str='32' value=32
// CHECK-NEXT:           UnaryExpr type=i64 - (Minus) opLoc=line:44:41
// CHECK-NEXT:             IntegerLiteralExpr type=i64 loc=line:44:42 str='64' value=64
// CHECK-NEXT:           UnaryExpr type=isize + (Plus) opLoc=line:44:46
// CHECK-NEXT:             IntegerLiteralExpr type=isize loc=line:44:47 str='0' value=0
// CHECK-NEXT:           UnaryExpr type=f32 + (Plus) opLoc=line:44:50
// CHECK-NEXT:             FloatLiteralExpr type=f32 loc=line:44:51 str='3.14' value=3.1400001
// CHECK-NEXT:           UnaryExpr type=f64 - (Minus) opLoc=line:44:57
// CHECK-NEXT:             FloatLiteralExpr type=f64 loc=line:44:58 str='3.6' value=3.6000000000000001
// CHECK-NEXT:   FuncDecl type=(&mut ((i32, i32), i16), (i32, i16), &((i32, i32), i16)) -> void identifier=membacc identifierLoc=line:48:6 fnLoc=line:48:1
// CHECK:            ParamDecl type=&mut ((i32, i32), i16) identifier=a identifierLoc=line:48:14
// CHECK:            ParamDecl type=(i32, i16) identifier=b identifierLoc=line:48:41
// CHECK:            ParamDecl type=&((i32, i32), i16) identifier=c identifierLoc=line:48:56
// CHECK:            LoadExpr implicit type=i32
// CHECK-NEXT:         TupleElementExpr type=@lvalue i32 dot opLoc=line:49:11 index=0 indexLoc=line:49:12
// CHECK-NEXT:           ParenExpr type=@lvalue (i32, i32) lParenLoc=line:49:5 rParenLoc=line:49:10
// CHECK-NEXT:             TupleElementExpr type=@lvalue (i32, i32) arrow opLoc=line:49:7 index=0 indexLoc=line:49:9
// CHECK-NEXT:               DeclRefExpr type=@lvalue &mut ((i32, i32), i16) loc=line:49:6 decl='a'@line:48:14
// CHECK-NEXT:       LoadExpr implicit type=i32
// CHECK-NEXT:         TupleElementExpr type=@lvalue i32 dot opLoc=line:50:6 index=0 indexLoc=line:50:7
// CHECK-NEXT:           DeclRefExpr type=@lvalue (i32, i16) loc=line:50:5 decl='b'@line:48:41
// CHECK-NEXT:       LoadExpr implicit type=i32
// CHECK-NEXT:         TupleElementExpr type=@lvalue i32 dot opLoc=line:51:11 index=0 indexLoc=line:51:12
// CHECK-NEXT:           ParenExpr type=@lvalue (i32, i32) lParenLoc=line:51:5 rParenLoc=line:51:10
// CHECK-NEXT:             TupleElementExpr type=@lvalue (i32, i32) arrow opLoc=line:51:7 index=0 indexLoc=line:51:9
// CHECK-NEXT:               DeclRefExpr type=@lvalue &((i32, i32), i16) loc=line:51:6 decl='c'@line:48:56
// CHECK-NEXT:   FuncDecl type=(i8) -> void identifier=implicit identifierLoc=line:54:6 fnLoc=line:54:1
// CHECK:            ParamDecl type=i8 identifier=a identifierLoc=line:54:15
// CHECK:            LetDecl letLoc=line:55:3 equalLoc=line:55:71
// CHECK:              TupleExpr type=(maybe i32, maybe i32, (maybe i32, maybe i32)) numElements=3 lParenLoc=line:55:73 rParenLoc=line:55:86
// CHECK-NEXT:           ImplicitMaybeConversionExpr implicit type=maybe i32
// CHECK-NEXT:             IntegerLiteralExpr type=i32 loc=line:55:74 str='0' value=0
// CHECK-NEXT:           ImplicitMaybeConversionExpr implicit type=maybe i32
// CHECK-NEXT:             IntegerLiteralExpr type=i32 loc=line:55:77 str='0' value=0
// CHECK-NEXT:           TupleExpr type=(maybe i32, maybe i32) numElements=2 lParenLoc=line:55:80 rParenLoc=line:55:85
// CHECK-NEXT:             ImplicitMaybeConversionExpr implicit type=maybe i32
// CHECK-NEXT:               IntegerLiteralExpr type=i32 loc=line:55:81 str='0' value=0
// CHECK-NEXT:             ImplicitMaybeConversionExpr implicit type=maybe i32
// CHECK-NEXT:               IntegerLiteralExpr type=i32 loc=line:55:84 str='0' value=0
// CHECK-NEXT:       LetDecl letLoc=line:56:3 equalLoc=line:56:20
// CHECK:              ImplicitMaybeConversionExpr implicit type=maybe &i8
// CHECK-NEXT:           UnaryExpr type=&i8 & (AddressOf) opLoc=line:56:22
// CHECK-NEXT:             DeclRefExpr type=@lvalue i8 loc=line:56:23 decl='a'@line:54:15
// CHECK-NEXT:       LetDecl letLoc=line:57:3 equalLoc=line:57:9
// CHECK:                VarDecl type=(i8, i8) identifier=a identifierLoc=line:57:7 immutable
// CHECK-NEXT:         TupleExpr type=(i8, i8) numElements=2 lParenLoc=line:57:11 rParenLoc=line:57:16
// CHECK-NEXT:           LoadExpr implicit type=i8
// CHECK-NEXT:             DeclRefExpr type=@lvalue i8 loc=line:57:12 decl='a'@line:54:15
// CHECK-NEXT:           LoadExpr implicit type=i8
// CHECK-NEXT:             DeclRefExpr type=@lvalue i8 loc=line:57:15 decl='a'@line:54:15
// CHECK-NEXT:       LetDecl letLoc=line:58:3 equalLoc=line:58:32
// CHECK:              DestructuredTupleExpr implicit type=(maybe i8, maybe i8)
// CHECK-NEXT:           LoadExpr implicit type=(i8, i8)
// CHECK-NEXT:             DeclRefExpr type=@lvalue (i8, i8) loc=line:58:34 decl='a'@line:57:7
// CHECK-NEXT:           TupleExpr implicit type=(maybe i8, maybe i8) numElements=2 range=[line:58:34, line:58:34]
// CHECK-NEXT:             ImplicitMaybeConversionExpr implicit type=maybe i8
// CHECK-NEXT:               DestructuredTupleElementExpr implicit type=i8 index=0
// CHECK-NEXT:             ImplicitMaybeConversionExpr implicit type=maybe i8
// CHECK-NEXT:               DestructuredTupleElementExpr implicit type=i8 index=1
// CHECK-NEXT:   FuncDecl type=(maybe maybe i32) -> void identifier=unwrap identifierLoc=line:61:6 fnLoc=line:61:1
// CHECK:            ParamDecl type=maybe maybe i32 identifier=z identifierLoc=line:61:13
// CHECK:            ForceUnwrapExpr type=i32 exclaimLoc=line:62:5
// CHECK-NEXT:         ForceUnwrapExpr type=maybe i32 exclaimLoc=line:62:4
// CHECK-NEXT:           LoadExpr implicit type=maybe maybe i32
// CHECK-NEXT:             DeclRefExpr type=@lvalue maybe maybe i32 loc=line:62:3 decl='z'@line:61:13
// CHECK-NEXT:   FuncDecl type=(&mut i32) -> void identifier=deref identifierLoc=line:65:6 fnLoc=line:65:1
// CHECK:            ParamDecl type=&mut i32 identifier=ref identifierLoc=line:65:12
// CHECK:            BinaryExpr type=i32 = (Assign) opLoc=line:66:8
// CHECK-NEXT:         UnaryExpr type=@lvalue i32 * (Deref) opLoc=line:66:3
// CHECK-NEXT:           LoadExpr implicit type=&mut i32
// CHECK-NEXT:             DeclRefExpr type=@lvalue &mut i32 loc=line:66:4 decl='ref'@line:65:12
// CHECK-NEXT:         IntegerLiteralExpr type=i32 loc=line:66:10 str='0' value=0
// CHECK-NEXT:   FuncDecl type=(&mut i8, i64, usize, f32) -> void identifier=casts identifierLoc=line:69:6 fnLoc=line:69:1
// CHECK:            ParamDecl type=&mut i8 identifier=a identifierLoc=line:69:12
// CHECK:            ParamDecl type=i64 identifier=x identifierLoc=line:69:24
// CHECK:            ParamDecl type=usize identifier=y identifierLoc=line:69:32
// CHECK:            ParamDecl type=f32 identifier=z identifierLoc=line:69:42
// CHECK:            CastExpr type=u16 asLoc=line:70:5 useless
// CHECK-NEXT:         IntegerLiteralExpr type=u16 loc=line:70:3 str='0' value=0
// CHECK:            CastExpr type=f64 asLoc=line:71:21
// CHECK-NEXT:         CastExpr type=usize asLoc=line:71:12
// CHECK-NEXT:           CastExpr type=f32 asLoc=line:71:5 useless
// CHECK-NEXT:             LoadExpr implicit type=f32
// CHECK-NEXT:               DeclRefExpr type=@lvalue f32 loc=line:71:3 decl='z'@line:69:42
// CHECK:            CastExpr type=u8 asLoc=line:72:5
// CHECK-NEXT:         LoadExpr implicit type=usize
// CHECK-NEXT:           DeclRefExpr type=@lvalue usize loc=line:72:3 decl='y'@line:69:32
// CHECK:            CastExpr type=usize asLoc=line:73:5
// CHECK-NEXT:         LoadExpr implicit type=i64
// CHECK-NEXT:           DeclRefExpr type=@lvalue i64 loc=line:73:3 decl='x'@line:69:24
// CHECK:            CastExpr type=bool asLoc=line:74:14
// CHECK-NEXT:         CastExpr type=u8 asLoc=line:74:8
// CHECK-NEXT:           BooleanLiteralExpr type=bool loc=line:74:3 value=true
// CHECK:            CastExpr type=maybe &i8 asLoc=line:75:5 useless
// CHECK-NEXT:         ImplicitMaybeConversionExpr implicit type=maybe &i8
// CHECK-NEXT:           MutToImmutReferenceExpr implicit type=&i8
// CHECK-NEXT:             LoadExpr implicit type=&mut i8
// CHECK-NEXT:               DeclRefExpr type=@lvalue &mut i8 loc=line:75:3 decl='a'@line:69:12
// CHECK:        FuncDecl type=() -> void identifier=tuples identifierLoc=line:78:6 fnLoc=line:78:1
// CHECK:            TupleExpr type=() numElements=0 lParenLoc=line:79:3 rParenLoc=line:79:4
// CHECK-NEXT:       ParenExpr type=i32 lParenLoc=line:80:3 rParenLoc=line:80:5
// CHECK-NEXT:         IntegerLiteralExpr type=i32 loc=line:80:4 str='0' value=0
// CHECK-NEXT:       TupleExpr type=(i32, i32) numElements=2 lParenLoc=line:81:3 rParenLoc=line:81:8
// CHECK-NEXT:         IntegerLiteralExpr type=i32 loc=line:81:4 str='0' value=0
// CHECK-NEXT:         IntegerLiteralExpr type=i32 loc=line:81:7 str='1' value=1
// CHECK-NEXT:       TupleExpr type=(i32, i32, i32) numElements=3 lParenLoc=line:82:3 rParenLoc=line:82:11
// CHECK-NEXT:         IntegerLiteralExpr type=i32 loc=line:82:4 str='0' value=0
// CHECK-NEXT:         IntegerLiteralExpr type=i32 loc=line:82:7 str='2' value=2
// CHECK-NEXT:         IntegerLiteralExpr type=i32 loc=line:82:10 str='3' value=3
