// NOTE: CHECK lines have been generated by utils/update_filecheck_test.py
// RUN: sorac -emit-sirgen -g %s | FileCheck %s

// Test for the mut, typed and paren patterns, which don't emit any code.

func foo() {
  // All of those groups should generate the exact same code.

  let a0 = 0
  let mut a1 = 0

  let b0 = 0
  let (b1) = 0

  let c0 = 0 as i8
  let c1: i8 = 0
}

// CHECK:      module @"{{.*}}" {
// CHECK-NEXT:   func @foo() {
// CHECK-NEXT:     %c0_i32 = constant 0 : i32 loc("{{.*}}":9:12)
// CHECK-NEXT:     %0 = sir.alloc_stack : !sir.pointer<i32> loc("{{.*}}":9:7)
// CHECK-NEXT:     sir.store %c0_i32 : i32 into %0 : !sir.pointer<i32> loc("{{.*}}":9:7)
// CHECK-NEXT:     %c0_i32_0 = constant 0 : i32 loc("{{.*}}":10:16)
// CHECK-NEXT:     %1 = sir.alloc_stack : !sir.pointer<i32> loc("{{.*}}":10:11)
// CHECK-NEXT:     sir.store %c0_i32_0 : i32 into %1 : !sir.pointer<i32> loc("{{.*}}":10:11)
// CHECK-NEXT:     %c0_i32_1 = constant 0 : i32 loc("{{.*}}":12:12)
// CHECK-NEXT:     %2 = sir.alloc_stack : !sir.pointer<i32> loc("{{.*}}":12:7)
// CHECK-NEXT:     sir.store %c0_i32_1 : i32 into %2 : !sir.pointer<i32> loc("{{.*}}":12:7)
// CHECK-NEXT:     %c0_i32_2 = constant 0 : i32 loc("{{.*}}":13:14)
// CHECK-NEXT:     %3 = sir.alloc_stack : !sir.pointer<i32> loc("{{.*}}":13:8)
// CHECK-NEXT:     sir.store %c0_i32_2 : i32 into %3 : !sir.pointer<i32> loc("{{.*}}":13:8)
// CHECK-NEXT:     %c0_i8 = constant 0 : i8 loc("{{.*}}":15:12)
// CHECK-NEXT:     %4 = sir.alloc_stack : !sir.pointer<i8> loc("{{.*}}":15:7)
// CHECK-NEXT:     sir.store %c0_i8 : i8 into %4 : !sir.pointer<i8> loc("{{.*}}":15:7)
// CHECK-NEXT:     %c0_i8_3 = constant 0 : i8 loc("{{.*}}":16:16)
// CHECK-NEXT:     %5 = sir.alloc_stack : !sir.pointer<i8> loc("{{.*}}":16:7)
// CHECK-NEXT:     sir.store %c0_i8_3 : i8 into %5 : !sir.pointer<i8> loc("{{.*}}":16:7)
// CHECK-NEXT:   } loc("{{.*}}":6:6)
// CHECK-NEXT: }
